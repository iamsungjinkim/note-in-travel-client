# 여행 줍줍 🧳
여행일정을 세우고 공유할 수 있는 모바일 앱입니다.  
지도 상의 공유된 일정을 확인할 수 있으며, 일정을 수행할 수 있습니다.  
여행 중 현재 위치에 쪽지를 남길 수 있고, 주변에 쪽지가 있다면 내용을 읽어 볼 수 있습니다.
<br>
<br>

## 💡프로젝트 동기
여행을 가는 것을 좋아하지만, 여행 일정을 세우는 것은 어려운 저와 같은 사람을 위한 어플을 만들고 싶었습니다. 여행일정을 손쉽게 만들고 공유할 수 있으며, 다른사람의 여행일정에 참여할 수 있습니다.  
어린시절 쪽지를 숨겨놓고 찾던, 보물찾기를 기억하시나요? 여행 중 추억과 이야기를 쪽지로 남길 수 있습니다. 쪽지는 근처에 있어야만 확인할 수 있습니다.
<br>
<br>

## 💁‍♂️프로젝트 설명
> 메인페이지
1. 공유되어 있는 일정을 지도에서 확인 할 수 있습니다.  
2. 거리가 가까운 일정들은 묶어서 확인이 가능합니다.  
3. 공유되어 있는 일정을 지도에서 확인 할 수 있습니다.  
4. 거리가 가까운 일정들은 묶어서 확인이 가능합니다.
> 일정 생성
1. 검색을 통하여 목적지를 선택 및 추가할 수 있습니다.
2. 특정 장소를 즐겨찾기에 추가할 수 있습니다.
3. 즐겨찾기한 장소를 간편하게 일정에 추가할 수 있습니다.
4. 방문할 장소의 순서를 변경할 수 있습니다.
5. 여행 일정의 제목을 입력하고 저장할 수 있습니다.
> 마이페이지
1. 내가 생성한 일정과 즐겨찾기한 일정의 목록을 확인할 수 있습니다.
2. 일정을 눌러 상세일정을 확인할 수 있습니다.
> 일정 상세 페이지
1. 일정의 점수 및 상세 정보를 확인 할 수 있습니다.
2. 타인의 일정일 경우, 즐겨찾기를 추가할 수 있습니다.
3. 하단의 일정수행버튼은 길게 누르면 일정수행 모드로 전환되고, 현재 나의 위치를 지도상에 표시해줍니다.
4. 일정 수행모드에서는 현재 나의 위치에 쪽지를 남길 수 있고, 근처의 쪽지를 확인할 수 있습니다.

|메인 페이지 |일정 생성(장소 검색) |일정 생성(즐겨찾기 장소) |일정 생성(순서 변경) |
|:--:|:--:|:--:|:--:|
|<img alt="메인페이지" src="https://user-images.githubusercontent.com/67359769/119762152-22c5a380-bee8-11eb-84c6-c3f3fc35582f.gif" width="150"> |<img alt="일정생성_장소검색" src="https://user-images.githubusercontent.com/67359769/119762607-fcecce80-bee8-11eb-90a5-a500bb6df6ab.gif" width="150"> |<img alt="일정생성_즐겨찾기_장소" src="https://user-images.githubusercontent.com/67359769/119763924-6e2d8100-beeb-11eb-8f7d-82abc8794462.gif" width="150"> |<img alt="일정생성_순서변경" src="https://user-images.githubusercontent.com/67359769/119799708-4bb15d00-bf17-11eb-8060-2b82ad15425b.gif" width="150"> |
|**일정 생성(저장)** |**마이페이지** |**일정 수행 & 쪽지** |
|<img alt="일정생성_저장" src="https://user-images.githubusercontent.com/67359769/119764048-a634c400-beeb-11eb-9a91-06477e4d37bb.gif" width="150"> |<img alt="마이페이지" src="https://user-images.githubusercontent.com/67359769/119799574-258bbd00-bf17-11eb-8d30-42f0d404bc32.gif" width="150"> |<img alt="일정수행 및 쪽지 작성" src="https://user-images.githubusercontent.com/67359769/119799632-376d6000-bf17-11eb-97ff-ae91677005d2.gif" width="150"> |

<br>
<br>

## 🚀키워드
**`Redux Normalize`**, **`Re-rendering`**  
지난 1차 프로젝트에서 AWS 요금이 청구된 경험을 하며 '서버에 요청을 보내는 부분도 최적화가 필요하지 않을까?'라는 생각을 하게되었습니다. 원인은 리팩토링 과정에서 소켓 연결 로직에서의 실수로 발생한 일이었지만, 이번 프로젝트에서 서버 요청에서의 최적화를 해보고 싶었습니다.  
로그인 시 유저관련 정보에 생성한 일정, 즐겨찾기 목록 등의 데이터를 함께 받는 것은 자연스럽다고 판단하였고, 즐겨찾기 목록 등의 데이터를 위한 요청을 별도로 분리하고 싶지 않았습니다. 하지만 한번의 로그인 요청을 통하여 받게되는 데이터를 redux store에 하나의 state로 관리하는 것은 비효율적이라고 생각하였고, 서버에서 유저 정보를 관리하는 데이터 형태와는 다른 형태로 redux state를 normalize하여 관리하게 되었습니다. 추가적인 이점으로 특정 상태의 업데이트가 불필요하게 다른 컴포넌트의 리렌더링을 유발하는 경우를 줄일 수 있었습니다.  
<br>

**`Custom Hook`**, **`Pure Function`**  
hook도 결국은 함수라는 생각으로 함수 추출의 기준에 따라 작성하려고 하였고, 그 과정에서 하나의 hook이 어느정도의 기능을 포함하는 것이 적절한가에 대한 결정이 쉽지 않다는 것을 느꼈습니다.  
이번 프로젝트에서 저는 다음과 같은 기준으로 custom hook을 만들고자 하였습니다.
- 관심사의 분리
- 로직의 재사용성

로직의 재사용성을 우선적으로 고려하여 hook을 분리하였더니, 하나의 컴포넌트에서 여러개의 custom hook의 반환값을 다뤄야하는 경우가 발생하였습니다. 관심사의 분리를 위하여, 여러 custom hook을 포함하는 또 다른 하나의 custom hook을 작성하는 것도 하나의 방법이었습니다. 하지만 1차 프로젝트에서 계층이 깊어질수록 코드의 흐름을 파악하는데 어려움을 겪었던 것과 유지보수에서의 어려움을 겪었던 경험이 있어, 다른 방법을 적용하였습니다.  
여러개의 custom hook을 다시 하나의 custom hook으로 묶는 경우 오히려 유지보수와 코드의 흐름을 파악하는 것에 어려움이 발생할 수 있다고 판단하여, 여러 custom hook의 반환값을 인자로 전달받아 로직을 수행하는 custom hook을 작성하는 방식을 선택하였습니다.  
덕분에 로직의 계층구조가 깊어지지않아서 흐름을 파악하기 수월하다는 장점이 있었으나, 컴포넌트의 관점에서 보았을때 관심사의 분리가 조금 아쉽다는 단점이 있었습니다. DRY한 코드를 작성하기 위하여 로직을 추출하는 것이 장점도 있으나 그로인해 발생하는 단점도 있다는 것을 다시한번 생각하게 되었습니다. trade off에 관해 다시 생각해볼 수 있는 좋은 기회가 되었다고 생각합니다.  
<br>

**`Spatial Hash Grid`**, **`Clustering`**  
핵심적인 기능 중, 현재 나의 위치를 기반으로 주변에 있는 쪽지만을 보여줘야하는 기능이 있습니다.  
현재 수행 중인 일정내의 모든 쪽지를 매번 검사하여, 보여줄지 숨길지의 여부를 판단할 수도 있었습니다. 하지만 쪽지의 수가 많아질 경우 나의 위치가 조금 변경될때마다 모든 쪽지를 모두 검사하여 거리를 계산하는 것은 매우 비효율적이라고 판단하였고, 효율적인 방법을 고민하였습니다.  
1차 프로젝트에서 게임관련 로직을 공부할 기회가 있었고, 그때 공부한 spatial hash gird을 참고하여 문제를 해결할 수 있었습니다.  
일정 내에 쪽지의 수가 많아져도 현재 내가 속한 단위 영역과 인근의 영역만을 탐색하는 방식으로 최적화를 적용할 수 있었고, spatial hash grid를 만드는 함수의 경우 memo를 이용하여 필요한 경우에만 재실행되도록 적용하였습니다. 위의 방식은 메인 페이지의 공유된 일정들을 합쳐서 보여주는, Clustering에도 활용할 수 있었습니다.  
React Three Fiber를 공부하면서 알게된 지식이, 전혀 관련이 없을 거라고 생각했던 지도를 다루는 부분에 사용할 수 있었다는 부분이 재미있는 경험이었습니다.  
<br>

**`Testing`**  
Test-driven Development(이하 TDD)는 오류를 최소화할 수 있고 이후에 코드를 다시 봤을때 로직의 의도를 파악하는데 도움을 주는 등 많은 이점이 있다고 생각합니다. 하지만 React Native를 처음 사용해본다는 걱정과 짧은 시간에 개발을 해야하기에 시간이 부족하지 않을까하는 걱정에 온전히 적용하지는 못하였으나, 개발을 진행하며 꼭 필요하다고 생각한 부분에 적용하였고 대표적으로 Spatial Hash Grid로직을 작성하며 TDD의 장점을 느낄 수 있었습니다.  
내부적으로 기능이 복잡하다고 생각하여 test를 먼저 작성한 후 하나씩 해결하는 방식으로 코드를 작성하였습니다. 이후 완성된 로직을 사용하며 여러 오류를 접하였으나, 테스트 코드를 통하여 검증된 부분이 있기에 버그를 찾는데 많은 시간을 절약할 수 있었고 TDD를 기반으로 작성한 코드에서는 거의 오류가 발생하지 않았습니다.  
React를 사용하였는가, React Native를 사용하였느나, Redux를 사용하였는가, React Navigation을 사용하였는가 등 어떠한 기술 스택을 이용하였는가에 따라 테스트 코드의 작성 방식이 조금씩 다르기때문에 각각의 경우에따라 다른 방식을 적용해야한다는 점을 알게되어 재밌고 좋은 경험이었습니다. TDD에 대해 더 공부하여, 다음에는 더 발전한 방법으로 TDD기반 개발을 진행해보고 싶다는 생각을 하였습니다.  
<br>

**`Version`**, **`Frame Work`**  
react native는 react와 달리, 테스트 코드 작성을 위하여 추가적인 환경설정이 필요했습니다.  
jest를 사용하기 위해 공식문서를 참고하여 설정을 잡고, 사용한 기술스택에 따른 추가적인 설정을 완료하였습니다. 하지만 테스트는 올바르게 작동하지 않았습니다.  
원인은 react-test-renderer의 버전이었습니다. react와 reat-test-renderer의 최신버전은 v17.0.2이지만, expo(v4.4.4)를 사용하여 프로젝트를 생성할 경우 react v16.13.1로 생성됩니다. 그로인해, 버전의 다름으로 발생된 오류였고, react-test-renderer의 버전을 낮추는 것으로 문제를 해결하였습니다.  
프레임워크를 사용할 경우, 내부적으로 어떤 라이브러리를 사용하고 버전은 어떤 버전을 사용하는지 등을 꼼꼼히 확인하는 것이 얼마나 중요한지를 느낄 수 있는 경험이었습니다.  
<br>
<br>

## 🏃프로젝트 기간
프로젝트는 총 3주간 진행하였습니다.  
1주차                |2주차                |3주차
:------------------:|:------------------:|:------------------:
21.05.03 ~ 21.05.07 |21.05.08 ~ 21.05.16 |21.05.17 ~ 21.05.21
`기획`               |`개발`               |`마무리`
브레인 스토밍<br> 목업<br> 스키마 설계<br> 개발 일정 계획 |기능 개발<br> 리팩토링 |리팩토링<br> 테스트 코드 작성<br> 배포

<br>
<br>

## 🙇‍♂️프로젝트를 마친 소감
